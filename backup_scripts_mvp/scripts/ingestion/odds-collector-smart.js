/**
 * SMART ODDS COLLECTOR - USUALODDS 2025
 * ====================================
 * Collecte intelligente des cotes Unibet avec v√©rification de disponibilit√©
 * Syst√®me adaptatif : v√©rifie selon la proximit√© du match
 */

const { createClient } = require('@supabase/supabase-js');
const { config } = require('dotenv');

// Charger les variables d'environnement
config();

// Client administrateur Supabase
const createAdminClient = () => {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.SUPABASE_SERVICE_ROLE_KEY
  );
};

const API_FOOTBALL_KEY = process.env.API_FOOTBALL_KEY;
const UNIBET_ID = 16; // ID Unibet dans API Football

/**
 * Calcule la strat√©gie de v√©rification selon la distance du match
 */
function getCheckStrategy(matchDate) {
  const now = new Date();
  const match = new Date(matchDate);
  const hoursUntilMatch = (match - now) / (1000 * 60 * 60);
  const daysUntilMatch = hoursUntilMatch / 24;
  
  console.log(`‚è∞ Match dans ${daysUntilMatch.toFixed(1)} jours (${hoursUntilMatch.toFixed(1)}h)`);
  
  if (hoursUntilMatch <= 0) {
    return { shouldCheck: false, reason: 'Match d√©j√† jou√©' };
  }
  
  // Strat√©gie intelligente selon la proximit√©
  if (daysUntilMatch > 7) {
    return { shouldCheck: false, reason: 'Match trop lointain (>7 jours)' };
  } else if (daysUntilMatch > 3) {
    return { shouldCheck: true, frequency: 'daily', reason: 'V√©rification quotidienne' };
  } else if (daysUntilMatch > 1) {
    return { shouldCheck: true, frequency: 'every-6h', reason: 'V√©rification toutes les 6h' };
  } else if (hoursUntilMatch > 6) {
    return { shouldCheck: true, frequency: 'hourly', reason: 'V√©rification horaire' };
  } else if (hoursUntilMatch > 2) {
    return { shouldCheck: true, frequency: 'every-30min', reason: 'V√©rification semi-horaire' };
  } else {
    return { shouldCheck: true, frequency: 'every-15min', reason: 'V√©rification intensive' };
  }
}

/**
 * V√©rifie si on a d√©j√† les cotes r√©centes pour un match
 */
async function hasRecentOdds(supabase, matchId, maxAgeHours = 6) {
  const cutoffTime = new Date(Date.now() - maxAgeHours * 60 * 60 * 1000);
  
  const { data, error } = await supabase
    .from('match_odds_timeline')
    .select('created_at')
    .eq('match_id', parseInt(matchId)) // matchId est ici l'api_id
    .eq('bookmaker', 'Unibet')
    .gte('created_at', cutoffTime.toISOString())
    .order('created_at', { ascending: false })
    .limit(1)
    .single();
    
  if (error && error.code !== 'PGRST116') {
    throw error;
  }
  
  return !!data;
}

/**
 * R√©cup√®re les cotes depuis API Football
 */
async function fetchOddsFromAPI(matchApiId) {
  try {
    console.log(`üîç R√©cup√©ration cotes API pour match ${matchApiId}...`);
    
    const url = `https://v3.football.api-sports.io/odds?fixture=${matchApiId}&bookmaker=${UNIBET_ID}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'X-RapidAPI-Key': API_FOOTBALL_KEY,
        'X-RapidAPI-Host': 'v3.football.api-sports.io'
      }
    });
    
    if (!response.ok) {
      throw new Error(`API Football error: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    
    if (!data.response || data.response.length === 0) {
      console.log(`‚ö†Ô∏è Aucune cote disponible pour match ${matchApiId}`);
      return null;
    }
    
    const oddsData = data.response[0];
    if (!oddsData.bookmakers || oddsData.bookmakers.length === 0) {
      console.log(`‚ö†Ô∏è Unibet non disponible pour match ${matchApiId}`);
      return null;
    }
    
    console.log(`‚úÖ Cotes Unibet r√©cup√©r√©es pour match ${matchApiId}`);
    return oddsData;
    
  } catch (error) {
    console.error(`‚ùå Erreur r√©cup√©ration cotes match ${matchApiId}:`, error.message);
    return null;
  }
}

/**
 * Extrait et formate les cotes selon la structure match_odds_timeline
 */
function extractMainOdds(oddsData) {
  const bookmaker = oddsData.bookmakers[0];
  const mainOdds = {
    odds_home: null,
    odds_draw: null,
    odds_away: null,
    odds_over_25: null,
    odds_under_25: null,
    odds_over_15: null,
    odds_under_15: null,
    odds_over_35: null,
    odds_under_35: null,
    odds_btts_yes: null,
    odds_btts_no: null
  };
  
  // Chercher les paris principaux
  for (const bet of bookmaker.bets) {
    switch (bet.name) {
      case 'Match Winner':
        const homeWin = bet.values.find(v => v.value === 'Home');
        const draw = bet.values.find(v => v.value === 'Draw');
        const awayWin = bet.values.find(v => v.value === 'Away');
        
        mainOdds.odds_home = homeWin ? parseFloat(homeWin.odd) : null;
        mainOdds.odds_draw = draw ? parseFloat(draw.odd) : null;
        mainOdds.odds_away = awayWin ? parseFloat(awayWin.odd) : null;
        break;
        
      case 'Goals Over/Under':
        const over15 = bet.values.find(v => v.value === 'Over 1.5');
        const under15 = bet.values.find(v => v.value === 'Under 1.5');
        const over25 = bet.values.find(v => v.value === 'Over 2.5');
        const under25 = bet.values.find(v => v.value === 'Under 2.5');
        const over35 = bet.values.find(v => v.value === 'Over 3.5');
        const under35 = bet.values.find(v => v.value === 'Under 3.5');
        
        mainOdds.odds_over_15 = over15 ? parseFloat(over15.odd) : null;
        mainOdds.odds_under_15 = under15 ? parseFloat(under15.odd) : null;
        mainOdds.odds_over_25 = over25 ? parseFloat(over25.odd) : null;
        mainOdds.odds_under_25 = under25 ? parseFloat(under25.odd) : null;
        mainOdds.odds_over_35 = over35 ? parseFloat(over35.odd) : null;
        mainOdds.odds_under_35 = under35 ? parseFloat(under35.odd) : null;
        break;
        
      case 'Both Teams Score':
        const btsYes = bet.values.find(v => v.value === 'Yes');
        const btsNo = bet.values.find(v => v.value === 'No');
        
        mainOdds.odds_btts_yes = btsYes ? parseFloat(btsYes.odd) : null;
        mainOdds.odds_btts_no = btsNo ? parseFloat(btsNo.odd) : null;
        break;
    }
  }
  
  return mainOdds;
}

/**
 * Calcule les probabilit√©s implicites et la marge du march√©
 */
function calculateProbabilities(odds_home, odds_draw, odds_away) {
  if (!odds_home || !odds_draw || !odds_away) {
    return {
      implied_prob_home: null,
      implied_prob_draw: null,
      implied_prob_away: null,
      market_margin: null
    };
  }
  
  // Probabilit√©s implicites (1/cote)
  const prob_home = 1 / odds_home;
  const prob_draw = 1 / odds_draw;  
  const prob_away = 1 / odds_away;
  
  // Somme des probabilit√©s (>1 √† cause de la marge bookmaker)
  const total_prob = prob_home + prob_draw + prob_away;
  
  // Marge du march√© (en pourcentage)
  const margin = ((total_prob - 1) * 100);
  
  return {
    implied_prob_home: parseFloat((prob_home * 100).toFixed(2)),
    implied_prob_draw: parseFloat((prob_draw * 100).toFixed(2)),
    implied_prob_away: parseFloat((prob_away * 100).toFixed(2)),
    market_margin: parseFloat(margin.toFixed(2))
  };
}

/**
 * Sauvegarde les cotes en base de donn√©es
 */
async function saveOdds(supabase, matchId, matchApiId, oddsData) {
  try {
    const mainOdds = extractMainOdds(oddsData);
    const bookmaker = oddsData.bookmakers[0];
    
    // Calculer probabilit√©s et marge
    const probabilities = calculateProbabilities(
      mainOdds.odds_home, 
      mainOdds.odds_draw, 
      mainOdds.odds_away
    );
    
    const oddsRecord = {
      match_id: parseInt(matchApiId), // Utiliser api_id (integer) au lieu de UUID
      bookmaker: bookmaker.name,
      timestamp: oddsData.update || new Date().toISOString(),
      ...mainOdds,
      ...probabilities,
      player_odds: null, // Pour futures cotes joueurs
      raw_odds: oddsData,
      created_at: new Date().toISOString()
    };
    
    // Insert (pas d'upsert car table timeline)
    const { data, error } = await supabase
      .from('match_odds_timeline')
      .insert([oddsRecord])
      .select()
      .single();
      
    if (error) {
      throw error;
    }
    
    console.log(`üíæ Cotes sauvegard√©es : ${mainOdds.odds_home} / ${mainOdds.odds_draw} / ${mainOdds.odds_away}`);
    console.log(`üìä Marge march√© : ${probabilities.market_margin}%`);
    return data;
    
  } catch (error) {
    console.error(`‚ùå Erreur sauvegarde cotes:`, error.message);
    throw error;
  }
}

/**
 * Traite un match pour collecter ses cotes
 */
async function processMatch(supabase, match) {
  const strategy = getCheckStrategy(match.date);
  
  console.log(`\nüîÑ ${match.home_team_name} vs ${match.away_team_name}`);
  console.log(`üìÖ ${new Date(match.date).toLocaleString('fr-FR')}`);
  console.log(`üéØ Strat√©gie: ${strategy.reason}`);
  
  if (!strategy.shouldCheck) {
    console.log(`‚è≠Ô∏è Skip: ${strategy.reason}`);
    return { status: 'skipped', reason: strategy.reason };
  }
  
  // V√©rifier si on a des cotes r√©centes
  try {
    const hasRecent = await hasRecentOdds(supabase, match.api_id);
    if (hasRecent && strategy.frequency !== 'every-15min') {
      console.log(`‚úÖ Cotes r√©centes d√©j√† disponibles`);
      return { status: 'has_recent', reason: 'Cotes r√©centes en cache' };
    }
  } catch (error) {
    console.log(`‚ö†Ô∏è Erreur v√©rification cache: ${error.message}`);
  }
  
  // R√©cup√©rer les cotes depuis l'API
  const oddsData = await fetchOddsFromAPI(match.api_id);
  
  if (!oddsData) {
    console.log(`‚ùå Cotes non disponibles`);
    return { status: 'no_odds', reason: 'Cotes non disponibles sur API' };
  }
  
  // Sauvegarder en base
  try {
    await saveOdds(supabase, match.api_id, match.api_id, oddsData);
    console.log(`‚úÖ Cotes mises √† jour avec succ√®s`);
    return { status: 'success', reason: 'Cotes r√©cup√©r√©es et sauvegard√©es' };
  } catch (error) {
    console.log(`‚ùå Erreur sauvegarde: ${error.message}`);
    return { status: 'error', reason: error.message };
  }
}

/**
 * Script principal
 */
async function main() {
  try {
    console.log('üöÄ SMART ODDS COLLECTOR - UNIBET');
    console.log('================================');
    
    // V√©rifier la cl√© API
    if (!API_FOOTBALL_KEY) {
      throw new Error('API_FOOTBALL_KEY manquante dans .env');
    }
    
    const supabase = createAdminClient();
    
    // R√©cup√©rer les matches √† venir (prochains 30 jours)
    const futureDate = new Date();
    futureDate.setDate(futureDate.getDate() + 30);
    
    console.log(`üìä R√©cup√©ration matches jusqu'au ${futureDate.toLocaleDateString('fr-FR')}...`);
    
    const { data: matches, error } = await supabase
      .from('matches')
      .select('id, api_id, home_team_name, away_team_name, date, status')
      .is('home_score', null)
      .is('away_score', null)
      .gte('date', new Date().toISOString())
      .lte('date', futureDate.toISOString())
      .order('date');
      
    if (error) {
      throw new Error(`Erreur Supabase: ${error.message}`);
    }
    
    console.log(`‚úÖ ${matches.length} matches √† venir trouv√©s`);
    
    // Statistiques
    const stats = {
      total: matches.length,
      processed: 0,
      success: 0,
      skipped: 0,
      no_odds: 0,
      has_recent: 0,
      errors: 0
    };
    
    // Traiter chaque match
    for (const match of matches) {
      const result = await processMatch(supabase, match);
      
      stats.processed++;
      stats[result.status]++;
      
      // Pause pour √©viter rate limiting (1 seconde)
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    console.log('\nüìä R√âSUM√â FINAL:');
    console.log(`‚úÖ Matches trait√©s: ${stats.processed}/${stats.total}`);
    console.log(`üéØ Succ√®s: ${stats.success}`);
    console.log(`üì¶ Cache r√©cent: ${stats.has_recent}`);
    console.log(`‚è≠Ô∏è Ignor√©s: ${stats.skipped}`);
    console.log(`‚ùå Cotes indispo: ${stats.no_odds}`);
    console.log(`üí• Erreurs: ${stats.errors}`);
    
    console.log('\nüéâ COLLECTE TERMIN√âE!');
    
  } catch (error) {
    console.error('\nüí• ERREUR CRITIQUE:', error.message);
    process.exit(1);
  }
}

// Ex√©cuter si appel√© directement
if (require.main === module) {
  main();
}

module.exports = { main };