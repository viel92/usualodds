const { createClient } = require('@supabase/supabase-js')

async function checkDuplicates() {
    console.log('üîç V√âRIFICATION DOUBLONS BASE DE DONN√âES')
    console.log('==========================================')
    
    const supabase = createClient(
        'https://agysfqhijfbnqzzooyeo.supabase.co',
        'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFneXNmcWhpamZibnF6em9veWVvIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NTUyODM5MSwiZXhwIjoyMDcxMTA0MzkxfQ.8YIs0qTIIJqHIKjFajj2FFl1PAR3b5rDcBi_ilVa45g'
    )
    
    try {
        // 1. V√©rifier les matchs
        console.log('üìä ANALYSE TABLE MATCHES...')
        
        // Total des matchs
        const { count: totalMatches } = await supabase
            .from('matches')
            .select('*', { count: 'exact', head: true })
        
        console.log(`Total matchs: ${totalMatches}`)
        
        // V√©rifier doublons par api_id (cl√© unique normalement)
        const { data: duplicateApiIds } = await supabase
            .from('matches')
            .select('api_id')
            .then(({ data }) => {
                const counts = {}
                data?.forEach(match => {
                    counts[match.api_id] = (counts[match.api_id] || 0) + 1
                })
                
                const duplicates = Object.entries(counts)
                    .filter(([_, count]) => count > 1)
                    .map(([api_id, count]) => ({ api_id: parseInt(api_id), count }))
                
                return { data: duplicates }
            })
        
        if (duplicateApiIds && duplicateApiIds.length > 0) {
            console.log(`‚ùå DOUBLONS API_ID d√©tect√©s: ${duplicateApiIds.length}`)
            console.log('Premiers doublons:', duplicateApiIds.slice(0, 5))
        } else {
            console.log('‚úÖ Aucun doublon api_id d√©tect√©')
        }
        
        // Distribution par saison
        const { data: seasonStats } = await supabase
            .from('matches')
            .select('season')
            .then(({ data }) => {
                const seasons = {}
                data?.forEach(match => {
                    seasons[match.season] = (seasons[match.season] || 0) + 1
                })
                return { data: seasons }
            })
        
        console.log('üìÖ Distribution par saison:')
        Object.entries(seasonStats || {}).forEach(([season, count]) => {
            console.log(`   ${season}: ${count} matchs`)
        })
        
        // 2. V√©rifier les √©quipes
        console.log('\nüèÜ ANALYSE TABLE TEAM_FEATURES...')
        
        const { count: totalTeams } = await supabase
            .from('team_features')
            .select('*', { count: 'exact', head: true })
        
        console.log(`Total team_features: ${totalTeams}`)
        
        // V√©rifier doublons √©quipes (team_id + season + league_id = unique)
        const { data: teamDuplicates } = await supabase
            .from('team_features')
            .select('team_id, season, league_id')
            .then(({ data }) => {
                const keys = {}
                data?.forEach(team => {
                    const key = `${team.team_id}-${team.season}-${team.league_id}`
                    keys[key] = (keys[key] || 0) + 1
                })
                
                const duplicates = Object.entries(keys)
                    .filter(([_, count]) => count > 1)
                    .map(([key, count]) => ({ key, count }))
                
                return { data: duplicates }
            })
        
        if (teamDuplicates && teamDuplicates.length > 0) {
            console.log(`‚ùå DOUBLONS √âQUIPES d√©tect√©s: ${teamDuplicates.length}`)
            console.log('Premiers doublons:', teamDuplicates.slice(0, 5))
        } else {
            console.log('‚úÖ Aucun doublon √©quipe d√©tect√©')
        }
        
        // 3. V√©rifier les joueurs
        console.log('\nüë§ ANALYSE TABLE PLAYER_FEATURES...')
        
        const { count: totalPlayers } = await supabase
            .from('player_features')
            .select('*', { count: 'exact', head: true })
        
        console.log(`Total player_features: ${totalPlayers}`)
        
        // 4. Analyse d√©taill√©e toutes les tables
        console.log('\nüìã ANALYSE COMPL√àTE TOUTES LES TABLES...')
        
        const tablesAnalysis = [
            'match_statistics',
            'match_events', 
            'match_formations',
            'match_lineups',
            'match_players_stats',
            'match_context',
            'match_odds_timeline',
            'coach_features',
            'ai_match_insights'
        ]
        
        for (const table of tablesAnalysis) {
            try {
                const { count } = await supabase
                    .from(table)
                    .select('*', { count: 'exact', head: true })
                
                console.log(`üìä ${table}: ${count || 0} entr√©es`)
                
                // Analyses sp√©cifiques par table
                if (table === 'match_statistics' && count > 0) {
                    // V√©rifier doublons match_statistics (match_id + team_id = unique)
                    const { data: matchStatsDuplicates } = await supabase
                        .from('match_statistics')
                        .select('match_id, team_id')
                        .then(({ data }) => {
                            const keys = {}
                            data?.forEach(stat => {
                                const key = `${stat.match_id}-${stat.team_id}`
                                keys[key] = (keys[key] || 0) + 1
                            })
                            
                            const duplicates = Object.entries(keys)
                                .filter(([_, count]) => count > 1)
                                .map(([key, count]) => ({ key, count }))
                            
                            return { data: duplicates }
                        })
                    
                    if (matchStatsDuplicates && matchStatsDuplicates.length > 0) {
                        console.log(`   ‚ùå ${matchStatsDuplicates.length} doublons d√©tect√©s`)
                    } else {
                        console.log(`   ‚úÖ Aucun doublon`)
                    }
                }
                
                if (table === 'match_events' && count > 0) {
                    // V√©rifier distribution des √©v√©nements par type
                    const { data: eventTypes } = await supabase
                        .from('match_events')
                        .select('type')
                        .limit(1000)
                        .then(({ data }) => {
                            const types = {}
                            data?.forEach(event => {
                                types[event.type] = (types[event.type] || 0) + 1
                            })
                            return { data: types }
                        })
                    
                    console.log(`   üìà Types d'√©v√©nements:`, Object.keys(eventTypes || {}).slice(0, 5).join(', '))
                }
                
                if (table === 'player_features' && count > 0) {
                    // V√©rifier doublons joueurs (player_id + team_id + season = unique)
                    const { data: playerDuplicates } = await supabase
                        .from('player_features')
                        .select('player_id, team_id, season')
                        .then(({ data }) => {
                            const keys = {}
                            data?.forEach(player => {
                                const key = `${player.player_id}-${player.team_id}-${player.season}`
                                keys[key] = (keys[key] || 0) + 1
                            })
                            
                            const duplicates = Object.entries(keys)
                                .filter(([_, count]) => count > 1)
                                .map(([key, count]) => ({ key, count }))
                            
                            return { data: duplicates }
                        })
                    
                    if (playerDuplicates && playerDuplicates.length > 0) {
                        console.log(`   ‚ùå ${playerDuplicates.length} doublons joueurs d√©tect√©s`)
                    } else {
                        console.log(`   ‚úÖ Aucun doublon joueur`)
                    }
                }
                
                if (table === 'match_lineups' && count > 0) {
                    // V√©rifier doublons lineups (match_id + player_id = unique)
                    const { data: lineupDuplicates } = await supabase
                        .from('match_lineups')
                        .select('match_id, player_id')
                        .then(({ data }) => {
                            const keys = {}
                            data?.forEach(lineup => {
                                const key = `${lineup.match_id}-${lineup.player_id}`
                                keys[key] = (keys[key] || 0) + 1
                            })
                            
                            const duplicates = Object.entries(keys)
                                .filter(([_, count]) => count > 1)
                                .map(([key, count]) => ({ key, count }))
                            
                            return { data: duplicates }
                        })
                    
                    if (lineupDuplicates && lineupDuplicates.length > 0) {
                        console.log(`   ‚ùå ${lineupDuplicates.length} doublons lineups d√©tect√©s`)
                    } else {
                        console.log(`   ‚úÖ Aucun doublon lineup`)
                    }
                }
                
            } catch (error) {
                console.log(`   ‚ùå Erreur analyse ${table}:`, error.message)
            }
        }
        
        // 5. RECOMMANDATIONS
        console.log('\nüí° RECOMMANDATIONS:')
        
        if (totalMatches > 1000) {
            console.log('‚ö†Ô∏è  Beaucoup de matchs d√©tect√©s')
            console.log('   ‚Üí V√©rifier si donn√©es de test √† nettoyer')
        }
        
        if (duplicateApiIds && duplicateApiIds.length > 0) {
            console.log('üßπ Nettoyage n√©cessaire: doublons api_id')
            console.log('   ‚Üí Garder la version la plus r√©cente (updated_at)')
        }
        
        if (teamDuplicates && teamDuplicates.length > 0) {
            console.log('üßπ Nettoyage n√©cessaire: doublons √©quipes')
            console.log('   ‚Üí Garder la version la plus r√©cente (updated_at)')
        }
        
        console.log('\nüéØ CONCLUSION:')
        if ((duplicateApiIds?.length || 0) === 0 && (teamDuplicates?.length || 0) === 0) {
            console.log('‚úÖ Base de donn√©es propre - pas de nettoyage n√©cessaire')
        } else {
            console.log('üßπ Nettoyage recommand√© avant phase pr√©dictions 2025')
        }
        
    } catch (error) {
        console.error('‚ùå Erreur v√©rification:', error.message)
    }
}

checkDuplicates().catch(console.error)