#!/usr/bin/env node

/**
 * ORCHESTRATEUR COMPLET LIGUE 1 MVP
 * 
 * PIPELINE:
 * 1. Collecte donn√©es compl√®tes Ligue 1 (stats + contexte + classement)
 * 2. Apprentissage IA patterns/styles
 * 3. G√©n√©ration features enrichies
 * 4. Validation & reporting
 * 
 * Usage: node run-ligue1-complete.js
 */

require('dotenv').config() // Charger variables d'environnement

const Ligue1MVPCollector = require('./ligue1-mvp-collector.js')
const AILearningEngine = require('./ai-learning-engine.js')
const { createClient } = require('@supabase/supabase-js')
const pLimit = require('p-limit')

// Configuration
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY)

class Ligue1CompleteOrchestrator {
    constructor() {
        // V√©rification environnement au d√©marrage
        if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY) {
            console.error('‚ùå Variables d\'environnement manquantes:')
            if (!SUPABASE_URL) console.error('   - NEXT_PUBLIC_SUPABASE_URL')
            if (!SUPABASE_SERVICE_KEY) console.error('   - SUPABASE_SERVICE_ROLE_KEY')
            process.exit(1)
        }
        
        this.collector = new Ligue1MVPCollector()
        this.aiEngine = new AILearningEngine()
        this.startTime = Date.now()
    }

    async run() {
        console.log('üöÄ D√âMARRAGE PIPELINE LIGUE 1 COMPLET')
        console.log('='.repeat(50))
        console.log('üìã √âtapes:')
        console.log('   1. üìä Collecte donn√©es compl√®tes')
        console.log('   2. üß† Apprentissage IA patterns')
        console.log('   3. üîÑ G√©n√©ration features enrichies')  
        console.log('   4. ‚úÖ Validation syst√®me')
        console.log('='.repeat(50))
        console.log()

        try {
            // === √âTAPE 1: COLLECTE DONN√âES ===
            console.log('üîÑ √âTAPE 1/4: Collecte donn√©es Ligue 1')
            await this.runDataCollection()
            console.log('‚úÖ Collecte termin√©e\n')

            // === √âTAPE 2: APPRENTISSAGE IA ===  
            console.log('üîÑ √âTAPE 2/4: Apprentissage IA')
            await this.runAILearning()
            console.log('‚úÖ Apprentissage IA termin√©\n')

            // === √âTAPE 3: ENRICHISSEMENT ===
            console.log('üîÑ √âTAPE 3/4: Enrichissement features')
            await this.runFeatureEnrichment()
            console.log('‚úÖ Enrichissement termin√©\n')

            // === √âTAPE 4: VALIDATION ===
            console.log('üîÑ √âTAPE 4/4: Validation syst√®me')
            const validation = await this.validateSystem()
            console.log('‚úÖ Validation termin√©e\n')

            // === REPORTING FINAL ===
            await this.generateFinalReport(validation)

        } catch (error) {
            console.error('üí• ERREUR PIPELINE:', error.message)
            console.error('Stack:', error.stack)
            process.exit(1)
        }
    }

    /**
     * √âTAPE 1: COLLECTE DONN√âES COMPL√àTES
     */
    async runDataCollection() {
        console.log('üìä Lancement collecteur MVP...')
        
        // Appliquer migration DB si n√©cessaire
        await this.ensureDBSchema()
        
        // Ex√©cuter collecte compl√®te
        await this.collector.run()
        
        console.log('üìà Collecte donn√©es termin√©e')
    }

    async ensureDBSchema() {
        console.log('üèóÔ∏è V√©rification sch√©ma base de donn√©es...')
        
        // V√©rifier si les nouvelles tables existent
        const { data: tables, error } = await supabase
            .from('information_schema.tables')
            .select('table_name')
            .eq('table_schema', 'public')
            .in('table_name', [
                'team_features', 
                'player_features', 
                'match_context',
                'ai_match_insights'
            ])

        if (error) {
            console.log('‚ÑπÔ∏è Impossible v√©rifier sch√©ma, continuons...')
            return
        }

        const existingTables = tables.map(t => t.table_name)
        const requiredTables = ['team_features', 'player_features', 'match_context', 'ai_match_insights']
        const missingTables = requiredTables.filter(t => !existingTables.includes(t))

        if (missingTables.length > 0) {
            console.log(`‚ö†Ô∏è Tables manquantes: ${missingTables.join(', ')}`)
            console.log('üí° Appliquez d\'abord: supabase db push')
        } else {
            console.log('‚úÖ Sch√©ma base de donn√©es OK')
        }
    }

    /**
     * √âTAPE 2: APPRENTISSAGE IA
     */
    async runAILearning() {
        console.log('üß† D√©marrage apprentissage IA...')
        
        // Attendre que la collecte soit suffisante
        await this.waitForSufficientData()
        
        // Lancer cycle apprentissage
        const learningResults = await this.aiEngine.runLearningCycle()
        
        console.log('üìä R√©sultats apprentissage:')
        console.log(`   ‚Ä¢ Patterns d√©tect√©s: ${learningResults.patterns_detected}`)
        console.log(`   ‚Ä¢ Corr√©lations: ${learningResults.correlations_found}`)
        console.log(`   ‚Ä¢ Clusters: ${learningResults.clusters_identified}`)
        
        return learningResults
    }

    async waitForSufficientData() {
        console.log('‚è≥ Attente donn√©es suffisantes pour IA...')
        
        // V√©rifier qu'on a assez d'√©quipes avec stats
        const { data: teams, error } = await supabase
            .from('team_features')
            .select('team_id')
            .not('raw_stats', 'is', null)

        const teamCount = teams?.length || 0
        
        if (teamCount < 10) {
            console.log(`‚ö†Ô∏è Seulement ${teamCount} √©quipes avec donn√©es`)
            console.log('‚ÑπÔ∏è L\'IA continuera mais avec pr√©cision limit√©e')
        } else {
            console.log(`‚úÖ ${teamCount} √©quipes disponibles pour apprentissage`)
        }
    }

    /**
     * √âTAPE 3: ENRICHISSEMENT FEATURES
     */
    async runFeatureEnrichment() {
        console.log('üîÑ Enrichissement features avec IA...')
        
        // Enrichir toutes les √©quipes avec features IA
        const { data: teams } = await supabase
            .from('team_features')
            .select('team_id, season')
            .eq('season', 2024)

        if (!teams) {
            console.log('‚ö†Ô∏è Aucune √©quipe trouv√©e pour enrichissement')
            return
        }

        console.log(`üîÑ Enrichissement ${teams.length} √©quipes...`)
        
        // Limitation de concurrence pour √©viter surcharge
        const { default: pLimit } = await import('p-limit')
        const limit = pLimit(3) // Max 3 requ√™tes simultan√©es
        
        const enrichmentPromises = teams.map(team => 
            limit(async () => {
                try {
                    // G√©n√©rer features IA pour l'√©quipe
                    const aiProfile = await this.aiEngine.getTeamAIProfile(team.team_id)
                    
                    // Mise √† jour avec nouvelles features
                    await this.updateTeamWithAIFeatures(team.team_id, aiProfile)
                    
                } catch (error) {
                    console.error(`‚ùå Erreur enrichissement √©quipe ${team.team_id}:`, error.message)
                }
            })
        )
        
        await Promise.all(enrichmentPromises)
        console.log('‚úÖ Enrichissement features termin√©')
    }

    async updateTeamWithAIFeatures(teamId, aiProfile) {
        // Mise √† jour avec upsert et onConflict pour robustesse
        const { error } = await supabase
            .from('team_features')
            .upsert({
                team_id: teamId,
                season: 2024,
                league_id: 61, // Ligue 1
                ai_features: aiProfile.ai_profile,
                style_cluster: aiProfile.tactical_style,
                updated_at: new Date().toISOString()
            }, { 
                onConflict: 'team_id,season,league_id',
                ignoreDuplicates: false 
            })

        if (error) {
            console.error(`Erreur update √©quipe ${teamId}:`, error.message)
        }
    }

    /**
     * √âTAPE 4: VALIDATION SYST√àME
     */
    async validateSystem() {
        console.log('üîç Validation syst√®me complet...')
        
        const validation = {
            data_quality: await this.validateDataQuality(),
            ai_readiness: await this.validateAIReadiness(),
            prediction_capability: await this.validatePredictionCapability(),
            integration_status: await this.validateIntegration()
        }

        console.log('üìä R√©sultats validation:')
        console.log(`   ‚Ä¢ Qualit√© donn√©es: ${validation.data_quality.score}/100`)
        console.log(`   ‚Ä¢ IA pr√™te: ${validation.ai_readiness.ready ? '‚úÖ' : '‚ùå'}`)
        console.log(`   ‚Ä¢ Pr√©dictions: ${validation.prediction_capability.functional ? '‚úÖ' : '‚ùå'}`)
        console.log(`   ‚Ä¢ Int√©gration: ${validation.integration_status.complete ? '‚úÖ' : '‚ùå'}`)

        return validation
    }

    async validateDataQuality() {
        // V√©rification qualit√© donn√©es collect√©es
        const { data: teams } = await supabase
            .from('team_features')
            .select('*')
            .eq('season', 2024)

        const { count: matchesCount } = await supabase
            .from('matches')
            .select('*', { count: 'exact', head: true })
            .eq('season', 2024)

        const teamsCount = teams?.length || 0

        let score = 0
        if (teamsCount >= 18) score += 40 // Ligue 1 compl√®te
        if (matchesCount >= 100) score += 30 // Suffisant matchs
        if (teams?.some(t => t.raw_stats)) score += 30 // Stats d√©taill√©es

        return {
            score,
            teams_collected: teamsCount,
            matches_collected: matchesCount || 0,
            has_detailed_stats: teams?.some(t => t.raw_stats) || false
        }
    }

    async validateAIReadiness() {
        // V√©rifier que l'IA a appris des patterns
        const { data: insights } = await supabase
            .from('ai_match_insights')
            .select('id')
            .limit(1)

        return {
            ready: !!insights?.length,
            insights_generated: insights?.length || 0
        }
    }

    async validatePredictionCapability() {
        try {
            // Test pr√©diction sur match exemple avec null checks
            if (this.collector?.teams?.size >= 2) {
                const teamIds = Array.from(this.collector.teams.keys()).slice(0, 2)
                const prediction = await this.aiEngine.generateMatchAIFeatures(
                    teamIds[0], 
                    teamIds[1]
                )
                
                return {
                    functional: !!prediction,
                    confidence: prediction?.confidence_score || 0
                }
            }
        } catch (error) {
            console.error('Erreur test pr√©diction:', error.message)
        }
        
        return { functional: false, confidence: 0 }
    }

    async validateIntegration() {
        // V√©rifier int√©gration compl√®te avec null checks stricts
        const checks = [
            (this.collector?.teams?.size || 0) > 0, // Collecteur fonctionnel
            (this.aiEngine?.patterns?.size || 0) >= 0 && this.aiEngine !== null, // IA initialis√©e
            // Plus de checks selon besoins
        ]
        
        return {
            complete: checks.every(check => check),
            checks_passed: checks.filter(c => c).length,
            total_checks: checks.length
        }
    }

    /**
     * REPORTING FINAL
     */
    async generateFinalReport(validation) {
        const duration = Math.round((Date.now() - this.startTime) / 1000)
        
        console.log()
        console.log('='.repeat(60))
        console.log('üìä RAPPORT FINAL - LIGUE 1 MVP COMPLET')
        console.log('='.repeat(60))
        console.log()
        
        console.log('‚è±Ô∏è PERFORMANCE:')
        console.log(`   ‚Ä¢ Dur√©e totale: ${duration}s`)
        console.log(`   ‚Ä¢ API calls utilis√©s: ${this.collector?.apiCallCount || 0}`)
        console.log(`   ‚Ä¢ √âquipes collect√©es: ${this.collector?.teams?.size || 0}`)
        console.log(`   ‚Ä¢ Matchs trait√©s: ${this.collector?.progress?.collected || 0}`)
        console.log()
        
        console.log('üß† INTELLIGENCE ARTIFICIELLE:')
        console.log(`   ‚Ä¢ Styles tactiques identifi√©s: ${validation.ai_readiness.insights_generated}`)
        console.log(`   ‚Ä¢ Syst√®me pr√©diction: ${validation.prediction_capability.functional ? 'Op√©rationnel' : 'En cours'}`)
        console.log(`   ‚Ä¢ Confiance moyenne: ${Math.round((validation.prediction_capability.confidence || 0) * 100)}%`)
        console.log()
        
        console.log('üìà QUALIT√â DONN√âES:')  
        console.log(`   ‚Ä¢ Score qualit√©: ${validation.data_quality.score}/100`)
        console.log(`   ‚Ä¢ √âquipes Ligue 1: ${validation.data_quality.teams_collected}/20`)
        console.log(`   ‚Ä¢ Stats d√©taill√©es: ${validation.data_quality.has_detailed_stats ? 'Oui' : 'Non'}`)
        console.log()
        
        console.log('üéØ STATUT SYST√àME:')
        if (validation.data_quality.score >= 70 && 
            validation.prediction_capability.functional) {
            console.log('   ‚úÖ SYST√àME OP√âRATIONNEL')
            console.log('   üìä Pr√™t pour pr√©dictions temps r√©el')
            console.log('   üöÄ Peut d√©marrer phase production')
        } else {
            console.log('   ‚ö†Ô∏è SYST√àME EN COURS DE FINALISATION')
            console.log('   üìã Actions requises:')
            if (validation.data_quality.score < 70) {
                console.log('      ‚Ä¢ Compl√©ter collecte donn√©es')
            }
            if (!validation.prediction_capability.functional) {
                console.log('      ‚Ä¢ Finaliser syst√®me pr√©diction')
            }
        }
        
        console.log()
        console.log('üîÑ PROCHAINES √âTAPES:')
        console.log('   1. Tests pr√©dictions sur matchs r√©cents') 
        console.log('   2. Calibrage probabilit√©s avec r√©sultats r√©els')
        console.log('   3. Interface utilisateur pr√©dictions')
        console.log('   4. D√©ploiement pipeline temps r√©el')
        console.log()
        console.log('='.repeat(60))
        console.log('üéâ PIPELINE LIGUE 1 MVP TERMIN√â')
        console.log('='.repeat(60))
    }
}

// Ex√©cution
if (require.main === module) {
    const orchestrator = new Ligue1CompleteOrchestrator()
    orchestrator.run().catch(console.error)
}

module.exports = Ligue1CompleteOrchestrator